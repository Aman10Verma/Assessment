const { Sequelize, DataTypes } = require("sequelize");
const User = require("../model/user.model"); // Adjust path to your Sequelize model
const bcrypt = require("bcrypt"); // For password hashing in tests

// Sequelize instance for PostgreSQL
const sequelize = new Sequelize(process.env.POSTGRES_URL, {
  logging: false, // Disable logging during tests
});

// Before all tests, synchronize the database
beforeAll(async () => {
  await sequelize.authenticate(); // Connect to the database
  await sequelize.sync({ force: true }); // Sync models, dropping all tables first
});

// After all tests, close the connection
afterAll(async () => {
  await sequelize.close();
});

// Before each test, clean up the database to avoid duplicate data issues
beforeEach(async () => {
  await User.destroy({ where: {} }); // Clear the users table before each test
});

// Helper function to simulate user login (using email and password)
const loginUser = async (user) => {
  const foundUser = await User.findOne({ where: { email: user.email } });
  if (!foundUser) {
    throw new Error("User not found");
  }

  // Compare password with hashed password in database
  const isMatch = await bcrypt.compare(user.password, foundUser.password);
  if (!isMatch) {
    throw new Error("Invalid credentials");
  }

  return { user: foundUser };
};

// User API Integration Tests
describe("User API Integration Tests", () => {

  it("should create a new user", async () => {
    const user = { name: "John", email: `john-${Date.now()}@example.com`, password: "password123" };

    // Hash the password before creating the user
    user.password = await bcrypt.hash(user.password, 10);

    // Create a new user
    const newUser = await User.create(user);

    // Check if the user object contains the id field (auto-generated by PostgreSQL)
    expect(newUser).toHaveProperty("id");
    expect(newUser.name).toBe(user.name);
    expect(newUser.email).toBe(user.email);
  });

  it("should not create a user with an existing email", async () => {
    const user = { name: "John", email: `john-${Date.now()}@example.com`, password: "password123" };

    // Hash the password and create the first user
    user.password = await bcrypt.hash(user.password, 10);
    await User.create(user);

    try {
      // Try creating another user with the same email (this should fail)
      await User.create(user);
    } catch (error) {
      // Expect an error to be thrown due to unique email constraint
      expect(error).toBeDefined();
      expect(error.name).toBe("SequelizeUniqueConstraintError");
    }
  });

  it("should retrieve all users", async () => {
    // Create a couple of users
    const user1 = { name: "Jane", email: `jane-${Date.now()}@example.com`, password: "password123" };
    const user2 = { name: "Doe", email: `doe-${Date.now()}@example.com`, password: "password123" };
    await User.create(user1);
    await User.create(user2);

    // Retrieve all users
    const users = await User.findAll();

    // Ensure that there are more than 0 users
    expect(users.length).toBeGreaterThan(0);
    expect(users[0]).toHaveProperty("id");
  });

  it("should login a user with valid credentials", async () => {
    // Create a test user
    const user = { name: "Jane", email: `jane-${Date.now()}@example.com`, password: bcrypt.hashSync("password123", 10) };
    const createdUser = await User.create(user);

    // Try to login with the correct credentials
    const loginResponse = await loginUser({ email: createdUser.email, password: "password123" });

    // Check if the login was successful
    expect(loginResponse.user.email).toBe(createdUser.email);
  });

  it("should not login with invalid credentials", async () => {
    // Create a test user
    const user = { name: "Jane", email: `jane-${Date.now()}@example.com`, password: bcrypt.hashSync("password123", 10) };
    await User.create(user);

    try {
      // Attempt login with incorrect password
      await loginUser({ email: user.email, password: "wrongpassword" });
    } catch (error) {
      // Expect an error to be thrown due to invalid credentials
      expect(error).toBeDefined();
      expect(error.message).toBe("Invalid credentials");
    }
  });

  it("should get a user by ID", async () => {
    const user = { name: "Alice", email: `alice-${Date.now()}@example.com`, password: bcrypt.hashSync("password123", 10) };
    const createdUser = await User.create(user);

    // Retrieve the user by ID
    const foundUser = await User.findByPk(createdUser.id);

    // Check if the retrieved user has the same id as the created user
    expect(foundUser).toBeDefined();
    expect(foundUser.id).toBe(createdUser.id);
  });

  it("should update a user by ID", async () => {
    const user = { name: "Bob", email: `bob-${Date.now()}@example.com`, password: bcrypt.hashSync("password123", 10) };
    const createdUser = await User.create(user);

    // Update the user's name
    createdUser.name = "Robert";
    const updatedUser = await createdUser.save();

    // Check if the name was updated correctly
    expect(updatedUser.name).toBe("Robert");
  });

  it("should delete a user by ID", async () => {
    const user = { name: "Charlie", email: `charlie-${Date.now()}@example.com`, password: bcrypt.hashSync("password123", 10) };
    const createdUser = await User.create(user);

    // Delete the user by ID
    await User.destroy({ where: { id: createdUser.id } });

    // Try to find the deleted user (should return null)
    const deletedUser = await User.findByPk(createdUser.id);
    expect(deletedUser).toBeNull();
  });
});
